"""
Polly Web Interface Penetration Testing
Browser-based security testing for client-side vulnerabilities.
"""

import time
import requests
import re


class WebPentestSuite:
    """Web interface penetration testing suite"""

    def __init__(self, base_url=None, use_live_server=False):
        self.use_live_server = use_live_server
        self.base_url = (
            base_url or "https://polly.pacnp.al"
            if use_live_server
            else "http://localhost:8000"
        )
        self.session = requests.Session()

        # Add user agent for live server testing
        if use_live_server:
            self.session.headers.update(
                {"User-Agent": "Polly-Security-Test/1.0 (Authorized Penetration Test)"}
            )

    def test_security_headers(self):
        """Test security headers implementation"""
        try:
            response = self.session.get(self.base_url)
            headers = response.headers

            security_headers = {
                "X-Frame-Options": ["DENY", "SAMEORIGIN"],
                "X-Content-Type-Options": ["nosniff"],
                "X-XSS-Protection": ["1; mode=block"],
                "Strict-Transport-Security": None,  # Should exist for HTTPS
                "Content-Security-Policy": None,
                "Referrer-Policy": ["strict-origin-when-cross-origin", "no-referrer"],
            }

            results = {}
            for header, expected_values in security_headers.items():
                header_value = headers.get(header)
                if not header_value:
                    results[header] = "MISSING"
                elif expected_values and header_value not in expected_values:
                    results[header] = f"WEAK: {header_value}"
                else:
                    results[header] = "OK"

            return results

        except Exception as e:
            return {"error": str(e)}


class TestClientSideSecurity:
    """Test client-side security vulnerabilities"""

    def setup_method(self):
        # Check if we're running in live server mode
        import os

        use_live = os.environ.get("PENTEST_LIVE_SERVER", "false").lower() == "true"
        base_url = os.environ.get(
            "PENTEST_BASE_URL",
            "https://polly.pacnp.al" if use_live else "http://localhost:8000",
        )
        self.pentest = WebPentestSuite(base_url=base_url, use_live_server=use_live)

    def test_security_headers_presence(self):
        """Test presence and strength of security headers"""
        results = self.pentest.test_security_headers()

        # Document current state
        print("\nSecurity Headers Analysis:")
        print("=" * 40)
        for header, status in results.items():
            print(f"{header}: {status}")

        # Critical headers should be present
        critical_headers = ["X-Frame-Options", "X-Content-Type-Options"]
        for header in critical_headers:
            if results.get(header) == "MISSING":
                print(f"WARNING: Critical security header missing: {header}")

    def test_content_security_policy(self):
        """Test Content Security Policy implementation"""
        try:
            response = self.pentest.session.get(self.pentest.base_url)
            csp = response.headers.get("Content-Security-Policy")

            if not csp:
                print("WARNING: Missing Content-Security-Policy header")
                return

            # Check for unsafe CSP directives
            unsafe_patterns = ["'unsafe-inline'", "'unsafe-eval'", "data:", "*"]

            csp_issues = []
            for pattern in unsafe_patterns:
                if pattern in csp:
                    csp_issues.append(f"Potentially unsafe directive: {pattern}")

            if csp_issues:
                print("CSP Security Issues:")
                for issue in csp_issues:
                    print(f"  - {issue}")

            # Check for required directives
            required_directives = ["default-src", "script-src", "style-src"]
            missing_directives = []

            for directive in required_directives:
                if directive not in csp:
                    missing_directives.append(directive)

            if missing_directives:
                print(f"Missing CSP directives: {missing_directives}")

        except Exception as e:
            print(f"Error testing CSP: {e}")

    def test_sensitive_data_exposure(self):
        """Test for sensitive data exposure in responses"""
        endpoints_to_test = [
            "/",
            "/dashboard",
            "/static/js/main.js",  # If exists
            "/static/css/main.css",  # If exists
        ]

        sensitive_patterns = [
            (r'password\s*[:=]\s*["\'][^"\']+["\']', "Hardcoded password"),
            (r'api[_-]?key\s*[:=]\s*["\'][^"\']+["\']', "API key"),
            (r'secret\s*[:=]\s*["\'][^"\']+["\']', "Secret"),
            (r'token\s*[:=]\s*["\'][^"\']{20,}["\']', "Long token"),
            (r'mysql://[^"\']+', "Database URL"),
            (r'postgres://[^"\']+', "Database URL"),
            (r'mongodb://[^"\']+', "Database URL"),
            (r"DISCORD_CLIENT_SECRET", "Discord client secret"),
            (r'SECRET_KEY\s*=\s*["\'][^"\']+["\']', "Secret key"),
        ]

        for endpoint in endpoints_to_test:
            try:
                response = self.pentest.session.get(
                    f"{self.pentest.base_url}{endpoint}"
                )
                if response.status_code == 200:
                    content = response.text

                    for pattern, description in sensitive_patterns:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            print(
                                f"WARNING: {description} found in {endpoint}: {matches}"
                            )

            except Exception as e:
                print(f"Error testing {endpoint}: {e}")

    def test_information_disclosure_errors(self):
        """Test for information disclosure in error messages"""
        # Test various error conditions
        error_endpoints = [
            "/nonexistent-page",
            "/htmx/poll/99999/details",
            "/htmx/poll/abc/details",
            "/htmx/channels?server_id=invalid",
            "/static/../../../etc/passwd",
            "/admin",
            "/.env",
            "/config.php",
            "/wp-admin/",
        ]

        for endpoint in error_endpoints:
            try:
                response = self.pentest.session.get(
                    f"{self.pentest.base_url}{endpoint}"
                )

                if response.status_code >= 400:
                    content = response.text.lower()

                    # Check for sensitive information in error messages
                    sensitive_info = [
                        "traceback",
                        "exception",
                        "database error",
                        "sql",
                        "internal server error",
                        "debug",
                        "stack trace",
                        "file not found: /",
                        "permission denied",
                    ]

                    for info in sensitive_info:
                        if info in content:
                            print(
                                f"WARNING: Sensitive info in error for {endpoint}: {info}"
                            )

            except Exception as e:
                print(f"Error testing error endpoint {endpoint}: {e}")


class TestInputValidationWeb:
    """Test web-based input validation vulnerabilities"""

    def setup_method(self):
        self.pentest = WebPentestSuite()

    def test_xss_in_parameters(self):
        """Test XSS vulnerabilities in URL parameters"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "';alert('XSS');//",
            "\"><script>alert('XSS')</script>",
        ]

        # Test parameters that might be reflected
        test_params = ["search", "filter", "error", "message", "redirect"]

        for param in test_params:
            for payload in xss_payloads:
                try:
                    url = f"{self.pentest.base_url}/?{param}={payload}"
                    response = self.pentest.session.get(url)

                    if response.status_code == 200:
                        content = response.text

                        # Check if payload is reflected without proper escaping
                        dangerous_patterns = [
                            "<script>",
                            "javascript:",
                            "onerror=",
                            "onload=",
                            "alert(",
                        ]

                        for pattern in dangerous_patterns:
                            if pattern in content:
                                print(
                                    f"WARNING: Potential XSS in {param} parameter with payload: {payload}"
                                )

                except Exception as e:
                    print(f"Error testing XSS in {param}: {e}")

    def test_path_traversal_static_files(self):
        """Test path traversal in static file serving"""
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "../../../proc/version",
            "../../../etc/hosts",
        ]

        for payload in traversal_payloads:
            try:
                url = f"{self.pentest.base_url}/static/{payload}"
                response = self.pentest.session.get(url)

                if response.status_code == 200:
                    content = response.text

                    # Check for system file content
                    system_indicators = [
                        "root:",
                        "[users]",
                        "Linux version",
                        "127.0.0.1",
                        "localhost",
                    ]

                    for indicator in system_indicators:
                        if indicator in content:
                            print(f"WARNING: Path traversal successful with {payload}")
                            break

            except Exception as e:
                print(f"Error testing path traversal with {payload}: {e}")

    def test_http_method_tampering(self):
        """Test HTTP method tampering vulnerabilities"""
        # Test endpoints with different HTTP methods
        endpoints = ["/htmx/polls", "/htmx/create-poll", "/htmx/settings", "/dashboard"]

        methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE"]

        for endpoint in endpoints:
            for method in methods:
                try:
                    response = self.pentest.session.request(
                        method, f"{self.pentest.base_url}{endpoint}"
                    )

                    # Check for unexpected method acceptance
                    if response.status_code not in [405, 501, 404, 401, 403]:
                        print(
                            f"INFO: {method} {endpoint} returned {response.status_code}"
                        )

                        # TRACE method should be disabled
                        if method == "TRACE" and response.status_code == 200:
                            print(f"WARNING: TRACE method enabled on {endpoint}")

                except Exception as e:
                    print(f"Error testing {method} on {endpoint}: {e}")


class TestAuthenticationWeb:
    """Test web authentication vulnerabilities"""

    def setup_method(self):
        self.pentest = WebPentestSuite()

    def test_authentication_bypass_attempts(self):
        """Test authentication bypass techniques"""
        # Test accessing protected endpoints without authentication
        protected_endpoints = [
            "/dashboard",
            "/htmx/polls",
            "/htmx/create-poll",
            "/htmx/settings",
            "/htmx/poll/1/details",
        ]

        for endpoint in protected_endpoints:
            try:
                response = self.pentest.session.get(
                    f"{self.pentest.base_url}{endpoint}"
                )

                # Should redirect to login or return 401/403
                if response.status_code == 200:
                    print(f"WARNING: Unauthenticated access to {endpoint}")
                elif response.status_code in [401, 403]:
                    print(f"OK: {endpoint} properly protected")
                elif response.status_code in [302, 307, 308]:
                    print(f"OK: {endpoint} redirects unauthenticated users")

            except Exception as e:
                print(f"Error testing authentication on {endpoint}: {e}")

    def test_session_management(self):
        """Test session management security"""
        try:
            # Make a request to trigger session creation
            response = self.pentest.session.get(f"{self.pentest.base_url}/login")

            # Check session cookies
            for cookie in self.pentest.session.cookies:
                cookie_name = cookie.name.lower()

                # Check for session-related cookies
                if any(
                    keyword in cookie_name
                    for keyword in ["session", "token", "auth", "login"]
                ):
                    # Check security attributes
                    if not cookie.secure and "https" in self.pentest.base_url:
                        print(
                            f"WARNING: Session cookie {cookie.name} missing Secure flag"
                        )

                    # Note: httponly and samesite attributes are not easily accessible
                    # through requests library, would need browser automation for full test
                    print(f"INFO: Found session cookie: {cookie.name}")

        except Exception as e:
            print(f"Error testing session management: {e}")


class TestBusinessLogicWeb:
    """Test business logic vulnerabilities via web interface"""

    def setup_method(self):
        self.pentest = WebPentestSuite()

    def test_rate_limiting(self):
        """Test rate limiting on web endpoints"""
        # Test rapid requests to various endpoints
        endpoints_to_test = ["/", "/login", "/auth/callback?code=test"]

        for endpoint in endpoints_to_test:
            print(f"Testing rate limiting on {endpoint}")

            # Send rapid requests
            responses = []
            for i in range(10):
                try:
                    response = self.pentest.session.get(
                        f"{self.pentest.base_url}{endpoint}", timeout=5
                    )
                    responses.append(response.status_code)
                    time.sleep(0.1)  # Small delay

                except Exception as e:
                    print(f"Error in rate limit test: {e}")
                    break

            # Check if rate limiting is applied
            rate_limited = any(code == 429 for code in responses)
            if rate_limited:
                print(f"OK: Rate limiting detected on {endpoint}")
            else:
                print(f"INFO: No rate limiting detected on {endpoint}")

    def test_cors_configuration(self):
        """Test CORS configuration"""
        malicious_origins = [
            "https://evil.com",
            "http://malicious-site.com",
            "null",
            "*",
        ]

        for origin in malicious_origins:
            try:
                headers = {"Origin": origin}
                response = self.pentest.session.get(
                    self.pentest.base_url, headers=headers
                )

                cors_header = response.headers.get("Access-Control-Allow-Origin")
                if cors_header:
                    if cors_header == "*" or cors_header == origin:
                        print(f"WARNING: Permissive CORS policy allows {origin}")
                    else:
                        print(f"OK: CORS properly restricts {origin}")

            except Exception as e:
                print(f"Error testing CORS with {origin}: {e}")


class TestFileUploadWeb:
    """Test file upload security via web interface"""

    def setup_method(self):
        self.pentest = WebPentestSuite()

    def test_file_upload_endpoint_discovery(self):
        """Test for file upload endpoints"""
        # Common file upload endpoints
        upload_endpoints = [
            "/upload",
            "/htmx/upload-image",
            "/api/upload",
            "/files/upload",
            "/media/upload",
        ]

        for endpoint in upload_endpoints:
            try:
                # Test with OPTIONS to see if upload is supported
                response = self.pentest.session.options(
                    f"{self.pentest.base_url}{endpoint}"
                )

                if response.status_code != 404:
                    print(f"INFO: Potential upload endpoint found: {endpoint}")

                    # Test with GET
                    get_response = self.pentest.session.get(
                        f"{self.pentest.base_url}{endpoint}"
                    )
                    print(f"  GET {endpoint}: {get_response.status_code}")

                    # Test with POST
                    post_response = self.pentest.session.post(
                        f"{self.pentest.base_url}{endpoint}"
                    )
                    print(f"  POST {endpoint}: {post_response.status_code}")

            except Exception as e:
                print(f"Error testing upload endpoint {endpoint}: {e}")


# Integration test runner
class TestWebPentestIntegration:
    """Integration test to run all web penetration tests"""

    def test_run_all_web_pentests(self):
        """Run all web penetration test suites"""
        test_classes = [
            TestClientSideSecurity,
            TestInputValidationWeb,
            TestAuthenticationWeb,
            TestBusinessLogicWeb,
            TestFileUploadWeb,
        ]

        results = {}

        print("\n" + "=" * 60)
        print("WEB PENETRATION TEST RESULTS")
        print("=" * 60)

        for test_class in test_classes:
            class_name = test_class.__name__
            results[class_name] = {"passed": 0, "failed": 0, "errors": []}

            print(f"\nRunning {class_name}...")
            print("-" * 40)

            # Get all test methods
            test_methods = [
                method for method in dir(test_class) if method.startswith("test_")
            ]

            for method_name in test_methods:
                try:
                    # Create instance and run test
                    instance = test_class()
                    instance.setup_method()
                    method = getattr(instance, method_name)
                    print(f"  Running {method_name}...")
                    method()
                    results[class_name]["passed"] += 1
                    print("    ✅ PASSED")
                except Exception as e:
                    results[class_name]["failed"] += 1
                    results[class_name]["errors"].append(f"{method_name}: {str(e)}")
                    print(f"    ❌ FAILED: {str(e)}")

        # Print final summary
        print("\n" + "=" * 60)
        print("WEB PENTEST SUMMARY")
        print("=" * 60)

        total_passed = 0
        total_failed = 0

        for class_name, result in results.items():
            passed = result["passed"]
            failed = result["failed"]
            total_passed += passed
            total_failed += failed

            status = "✅ PASS" if failed == 0 else "❌ FAIL"
            print(f"{status} {class_name}: {passed} passed, {failed} failed")

        print("=" * 60)
        print(f"TOTAL: {total_passed} passed, {total_failed} failed")
        print("=" * 60)

        return results


if __name__ == "__main__":
    # Run the web penetration tests
    integration_test = TestWebPentestIntegration()
    integration_test.test_run_all_web_pentests()
