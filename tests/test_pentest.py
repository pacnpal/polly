"""
Polly Application Penetration Testing Suite
Comprehensive security testing for API endpoints and web interface.
"""

from fastapi.testclient import TestClient
from jose import jwt
from datetime import datetime, timedelta
import pytz

from polly.web_app import create_app
from polly.auth import SECRET_KEY, create_access_token, DiscordUser


class PentestSuite:
    """Comprehensive penetration testing suite for Polly application"""

    def __init__(self, base_url=None, use_live_server=False):
        self.use_live_server = use_live_server
        self.base_url = (
            base_url or "https://polly.pacnp.al"
            if use_live_server
            else "http://localhost:8000"
        )

        if use_live_server:
            # For live server testing, use requests session instead of TestClient
            import requests

            self.session = requests.Session()
            self.client = None
        else:
            # For local testing, use FastAPI TestClient
            self.app = create_app()
            self.client = TestClient(self.app)
            self.session = None

        self.test_user = self.create_test_user()
        self.admin_token = self.create_admin_token()
        self.regular_token = self.create_regular_token()

    def make_request(self, method, url, **kwargs):
        """Make HTTP request using appropriate client"""
        if self.use_live_server:
            # Use requests session for live server
            full_url = url if url.startswith("http") else f"{self.base_url}{url}"
            return self.session.request(method, full_url, **kwargs)
        else:
            # Use TestClient for local testing
            return self.client.request(method, url, **kwargs)

    def create_test_user(self):
        """Create a test Discord user"""
        user_data = {"id": "123456789", "username": "testuser", "avatar": "test_avatar"}
        guilds_data = [
            {"id": "987654321", "permissions": "8"}  # Administrator permission
        ]
        return DiscordUser(user_data, guilds_data)

    def create_admin_token(self):
        """Create admin JWT token for testing"""
        return create_access_token(self.test_user)

    def create_regular_token(self):
        """Create regular user JWT token (no admin permissions)"""
        user_data = {
            "id": "111111111",
            "username": "regularuser",
            "avatar": "regular_avatar",
        }
        guilds_data = [
            {"id": "987654321", "permissions": "0"}  # No permissions
        ]
        regular_user = DiscordUser(user_data, guilds_data)
        return create_access_token(regular_user)


class TestAuthenticationSecurity:
    """Test authentication and authorization vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_jwt_token_manipulation(self):
        """Test JWT token manipulation attacks"""
        # Test 1: Invalid signature
        payload = {
            "sub": "malicious_user",
            "username": "hacker",
            "admin_guilds": ["987654321"],
            "exp": datetime.now(pytz.UTC) + timedelta(hours=24),
        }
        malicious_token = jwt.encode(payload, "wrong_secret", algorithm="HS256")

        response = self.pentest.client.get(
            "/dashboard", cookies={"access_token": malicious_token}
        )
        assert response.status_code == 401

    def test_token_expiration(self):
        """Test expired token handling"""
        # Create expired token
        payload = {
            "sub": "123456789",
            "username": "testuser",
            "admin_guilds": ["987654321"],
            "exp": datetime.now(pytz.UTC) - timedelta(hours=1),  # Expired
        }
        expired_token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")

        response = self.pentest.client.get(
            "/dashboard", cookies={"access_token": expired_token}
        )
        assert response.status_code == 401

    def test_privilege_escalation(self):
        """Test privilege escalation attempts"""
        # Test accessing admin endpoints with regular user token
        response = self.pentest.client.get(
            "/htmx/create-form", cookies={"access_token": self.pentest.regular_token}
        )
        # Should still allow access but with limited permissions
        assert response.status_code in [200, 403]

    def test_session_fixation(self):
        """Test session fixation vulnerabilities"""
        # Test if old tokens remain valid after new login
        old_token = self.pentest.admin_token

        # Simulate new login
        new_token = self.pentest.create_admin_token()

        # Both tokens should be valid (this is expected behavior for JWT)
        response1 = self.pentest.client.get(
            "/dashboard", cookies={"access_token": old_token}
        )
        response2 = self.pentest.client.get(
            "/dashboard", cookies={"access_token": new_token}
        )

        assert response1.status_code == 200
        assert response2.status_code == 200

    def test_oauth_callback_manipulation(self):
        """Test OAuth callback manipulation"""
        # Test with malicious code parameter
        response = self.pentest.client.get("/auth/callback?code=malicious_code")
        assert response.status_code == 400

        # Test with missing code parameter
        response = self.pentest.client.get("/auth/callback")
        assert response.status_code == 422  # FastAPI validation error


class TestInputValidationSecurity:
    """Test input validation and injection vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_sql_injection_poll_creation(self):
        """Test SQL injection in poll creation"""
        malicious_payloads = [
            "'; DROP TABLE polls; --",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO polls (name) VALUES ('hacked'); --",
            "' OR '1'='1",
            "'; UPDATE polls SET creator_id='hacker' WHERE id=1; --",
        ]

        for payload in malicious_payloads:
            poll_data = {
                "name": payload,
                "question": "Test question",
                "options": ["Option 1", "Option 2"],
                "server_id": "987654321",
                "channel_id": "123456789",
                "open_time": "2025-01-01T12:00:00",
                "close_time": "2025-01-02T12:00:00",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should not cause server error
            assert response.status_code != 500

    def test_xss_in_poll_content(self):
        """Test XSS vulnerabilities in poll content"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//",
            "<iframe src=javascript:alert('XSS')></iframe>",
        ]

        for payload in xss_payloads:
            poll_data = {
                "name": f"Test Poll {payload}",
                "question": f"Test question {payload}",
                "options": [f"Option 1 {payload}", "Option 2"],
                "server_id": "987654321",
                "channel_id": "123456789",
                "open_time": "2025-01-01T12:00:00",
                "close_time": "2025-01-02T12:00:00",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Check if XSS payload is properly escaped in response
            if response.status_code == 200:
                assert "<script>" not in response.text
                assert "javascript:" not in response.text
                assert "onerror=" not in response.text

    def test_path_traversal_file_upload(self):
        """Test path traversal in file upload"""
        malicious_filenames = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
        ]

        for filename in malicious_filenames:
            # Create a test file
            test_content = b"test image content"
            files = {"file": (filename, test_content, "image/png")}

            response = self.pentest.make_request(
                "POST",
                "/htmx/upload-image",
                files=files,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should reject malicious filenames or return 404 if endpoint doesn't exist
            assert response.status_code in [400, 404, 422]

    def test_command_injection(self):
        """Test command injection vulnerabilities"""
        command_payloads = [
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
            "`whoami`",
            "$(id)",
            "; python -c 'import os; os.system(\"ls\")'",
        ]

        for payload in command_payloads:
            poll_data = {
                "name": f"Test{payload}",
                "question": "Test question",
                "options": ["Option 1", "Option 2"],
                "server_id": "987654321",
                "channel_id": "123456789",
                "open_time": "2025-01-01T12:00:00",
                "close_time": "2025-01-02T12:00:00",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should not execute commands
            assert response.status_code != 500


class TestFileUploadSecurity:
    """Test file upload security vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_malicious_file_upload(self):
        """Test upload of malicious files"""
        malicious_files = [
            # PHP shell
            ("shell.php", b"<?php system($_GET['cmd']); ?>", "image/png"),
            # Python script
            ("script.py", b"import os; os.system('rm -rf /')", "image/jpeg"),
            # Executable
            ("malware.exe", b"\x4d\x5a\x90\x00", "image/gif"),
            # HTML with JavaScript
            ("xss.html", b"<script>alert('XSS')</script>", "image/png"),
            # SVG with JavaScript
            ("xss.svg", b"<svg onload=\"alert('XSS')\"></svg>", "image/svg+xml"),
        ]

        for filename, content, mimetype in malicious_files:
            files = {"file": (filename, content, mimetype)}

            response = self.pentest.make_request(
                "POST",
                "/htmx/upload-image",
                files=files,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should reject malicious files or return 404 if endpoint doesn't exist
            if response.status_code == 404:
                # Endpoint doesn't exist - this is acceptable
                continue
            elif response.status_code == 200:
                # If upload succeeds, verify file is properly handled
                assert (
                    "error" not in response.text.lower()
                    or "success" in response.text.lower()
                )
            else:
                # Should reject malicious files
                assert response.status_code in [400, 403, 422]

    def test_oversized_file_upload(self):
        """Test upload of oversized files"""
        # Create a large file (10MB)
        large_content = b"A" * (10 * 1024 * 1024)
        files = {"file": ("large.png", large_content, "image/png")}

        response = self.pentest.make_request(
            "POST",
            "/htmx/upload-image",
            files=files,
            cookies={"access_token": self.pentest.admin_token},
        )

        # Should reject oversized files or return 404 if endpoint doesn't exist
        assert response.status_code in [400, 404, 413, 422]

    def test_file_type_bypass(self):
        """Test file type validation bypass"""
        bypass_attempts = [
            # Double extension
            ("image.php.png", b"<?php echo 'test'; ?>", "image/png"),
            # Null byte injection
            ("image.php\x00.png", b"<?php echo 'test'; ?>", "image/png"),
            # Case variation
            ("IMAGE.PHP", b"<?php echo 'test'; ?>", "image/png"),
            # MIME type spoofing
            ("script.js", b"alert('xss')", "image/png"),
        ]

        for filename, content, mimetype in bypass_attempts:
            files = {"file": (filename, content, mimetype)}

            response = self.pentest.make_request(
                "POST",
                "/htmx/upload-image",
                files=files,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should properly validate file types or return 404 if endpoint doesn't exist
            if response.status_code == 404:
                # Endpoint doesn't exist - this is acceptable
                continue
            elif response.status_code == 200:
                # Verify the file is handled safely
                assert (
                    "uploaded" in response.text.lower()
                    or "success" in response.text.lower()
                )
            else:
                # Should reject invalid file types
                assert response.status_code in [400, 403, 422]


class TestAPIEndpointSecurity:
    """Test API endpoint security vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_unauthorized_poll_access(self):
        """Test unauthorized access to polls"""
        # Test accessing polls without authentication
        response = self.pentest.client.get("/htmx/polls")
        assert response.status_code == 401

        # Test accessing specific poll details
        response = self.pentest.client.get("/htmx/poll/1/details")
        assert response.status_code == 401

    def test_poll_manipulation_attacks(self):
        """Test poll manipulation attacks"""
        # Test modifying other users' polls
        poll_data = {
            "name": "Hacked Poll",
            "question": "Hacked question",
            "options": ["Hack 1", "Hack 2"],
            "server_id": "987654321",
            "channel_id": "123456789",
        }

        # Try to edit poll with regular user token
        response = self.pentest.client.post(
            "/htmx/poll/1/edit",
            data=poll_data,
            cookies={"access_token": self.pentest.regular_token},
        )

        # Should be forbidden or not found
        assert response.status_code in [403, 404]

    def test_mass_assignment_attacks(self):
        """Test mass assignment vulnerabilities"""
        # Try to assign additional fields
        poll_data = {
            "name": "Test Poll",
            "question": "Test question",
            "options": ["Option 1", "Option 2"],
            "server_id": "987654321",
            "channel_id": "123456789",
            "creator_id": "hacker_id",  # Should not be assignable
            "id": "999",  # Should not be assignable
            "votes": "100",  # Should not be assignable
            "is_admin": "true",  # Should not be assignable
        }

        response = self.pentest.client.post(
            "/htmx/create-poll",
            data=poll_data,
            cookies={"access_token": self.pentest.admin_token},
        )

        # Should ignore unauthorized fields
        assert response.status_code in [200, 400, 422]

    def test_rate_limiting(self):
        """Test rate limiting on API endpoints"""
        # Rapid fire requests to create polls
        for i in range(20):
            poll_data = {
                "name": f"Spam Poll {i}",
                "question": "Spam question",
                "options": ["Option 1", "Option 2"],
                "server_id": "987654321",
                "channel_id": "123456789",
                "open_time": "2025-01-01T12:00:00",
                "close_time": "2025-01-02T12:00:00",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should eventually rate limit (429) or continue allowing (200)
            assert response.status_code in [200, 400, 422, 429]

    def test_parameter_pollution(self):
        """Test HTTP parameter pollution"""
        # Send duplicate parameters
        response = self.pentest.client.get(
            "/htmx/polls?filter=active&filter=closed&filter=scheduled",
            cookies={"access_token": self.pentest.admin_token},
        )

        # Should handle parameter pollution gracefully
        assert response.status_code == 200


class TestBusinessLogicSecurity:
    """Test business logic vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_poll_time_manipulation(self):
        """Test poll time manipulation attacks"""
        # Test creating poll with past dates
        poll_data = {
            "name": "Time Travel Poll",
            "question": "Can you time travel?",
            "options": ["Yes", "No"],
            "server_id": "987654321",
            "channel_id": "123456789",
            "open_time": "2020-01-01T12:00:00",  # Past date
            "close_time": "2020-01-02T12:00:00",  # Past date
        }

        response = self.pentest.client.post(
            "/htmx/create-poll",
            data=poll_data,
            cookies={"access_token": self.pentest.admin_token},
        )

        # Should validate time constraints
        assert response.status_code in [200, 400, 422]

    def test_poll_option_limits(self):
        """Test poll option limit bypass"""
        # Try to create poll with excessive options
        excessive_options = [f"Option {i}" for i in range(100)]

        poll_data = {
            "name": "Too Many Options",
            "question": "Which option?",
            "options": excessive_options,
            "server_id": "987654321",
            "channel_id": "123456789",
            "open_time": "2025-01-01T12:00:00",
            "close_time": "2025-01-02T12:00:00",
        }

        response = self.pentest.client.post(
            "/htmx/create-poll",
            data=poll_data,
            cookies={"access_token": self.pentest.admin_token},
        )

        # Should enforce option limits
        assert response.status_code in [200, 400, 422]

    def test_emoji_injection(self):
        """Test emoji injection attacks"""
        malicious_emojis = [
            "<:fake:123456789>",  # Fake Discord emoji
            "🏴‍☠️💀☠️",  # Unicode sequences
            "\u200b\u200c\u200d",  # Zero-width characters
            "😀" * 100,  # Excessive emojis
        ]

        for emoji_payload in malicious_emojis:
            poll_data = {
                "name": "Emoji Test",
                "question": "Test question",
                "options": ["Option 1", "Option 2"],
                "emojis": [emoji_payload, "😀"],
                "server_id": "987654321",
                "channel_id": "123456789",
                "open_time": "2025-01-01T12:00:00",
                "close_time": "2025-01-02T12:00:00",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            # Should validate emojis properly
            assert response.status_code in [200, 400, 422]


class TestInformationDisclosure:
    """Test information disclosure vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_error_message_disclosure(self):
        """Test sensitive information in error messages"""
        # Trigger various error conditions
        error_triggers = [
            ("/htmx/poll/99999/details", "Non-existent poll"),
            ("/htmx/poll/abc/details", "Invalid poll ID"),
            ("/htmx/channels?server_id=invalid", "Invalid server ID"),
        ]

        for endpoint, description in error_triggers:
            response = self.pentest.client.get(
                endpoint, cookies={"access_token": self.pentest.admin_token}
            )

            # Check for sensitive information disclosure
            if response.status_code >= 400:
                response_text = response.text.lower()
                sensitive_patterns = [
                    "traceback",
                    "exception",
                    "database",
                    "sql",
                    "secret",
                    "token",
                    "password",
                    "internal server error",
                ]

                for pattern in sensitive_patterns:
                    assert pattern not in response_text, (
                        f"Sensitive info disclosed: {pattern}"
                    )

    def test_user_enumeration(self):
        """Test user enumeration vulnerabilities"""
        # Test different user IDs to see if valid users can be enumerated
        user_ids = ["123456789", "999999999", "invalid_user", ""]

        for user_id in user_ids:
            # This would require implementing user profile endpoints
            # For now, test with existing endpoints that might reveal user info
            response = self.pentest.client.get(
                "/htmx/polls", cookies={"access_token": self.pentest.admin_token}
            )

            # Should not reveal information about other users
            assert response.status_code in [200, 401, 403]

    def test_directory_traversal_static_files(self):
        """Test directory traversal in static file serving"""
        traversal_paths = [
            "/static/../../../etc/passwd",
            "/static/..\\..\\..\\windows\\system32\\config\\sam",
            "/static/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "/static/....//....//....//etc/passwd",
        ]

        for path in traversal_paths:
            response = self.pentest.client.get(path)

            # Should not serve system files
            assert response.status_code in [404, 403]
            if response.status_code == 200:
                # If it returns content, it shouldn't be system files
                assert "root:" not in response.text
                assert "[users]" not in response.text


class TestCSRFAndClickjacking:
    """Test CSRF and clickjacking vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_csrf_protection(self):
        """Test CSRF protection on state-changing operations"""
        # Test poll creation without proper headers
        poll_data = {
            "name": "CSRF Test Poll",
            "question": "CSRF question",
            "options": ["Option 1", "Option 2"],
            "server_id": "987654321",
            "channel_id": "123456789",
        }

        # Remove CSRF headers and cookies
        response = self.pentest.client.post(
            "/htmx/create-poll",
            data=poll_data,
            headers={"Origin": "https://malicious-site.com"},
        )

        # Should require authentication
        assert response.status_code == 401

    def test_clickjacking_protection(self):
        """Test clickjacking protection headers"""
        response = self.pentest.client.get("/dashboard")

        # Check for security headers
        headers = response.headers

        # Should have clickjacking protection
        # Note: FastAPI doesn't set these by default, so this test documents the need
        x_frame_options = headers.get("X-Frame-Options")
        csp = headers.get("Content-Security-Policy")

        # Document current state - these should be implemented
        print(f"X-Frame-Options: {x_frame_options}")
        print(f"Content-Security-Policy: {csp}")


class TestDatabaseSecurity:
    """Test database security vulnerabilities"""

    def setup_method(self):
        self.pentest = PentestSuite()

    def test_database_file_access(self):
        """Test direct database file access"""
        # Try to access database file directly
        db_paths = ["/static/polls.db", "/static/../polls.db", "/polls.db"]

        for path in db_paths:
            response = self.pentest.client.get(path)

            # Should not serve database files
            assert response.status_code in [404, 403]

    def test_sql_injection_advanced(self):
        """Test advanced SQL injection techniques"""
        # Time-based blind SQL injection
        time_payloads = [
            "'; WAITFOR DELAY '00:00:05'; --",
            "' OR (SELECT COUNT(*) FROM polls) > 0 AND (SELECT SLEEP(5)); --",
            "'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END; --",
        ]

        for payload in time_payloads:
            start_time = datetime.now()

            poll_data = {
                "name": payload,
                "question": "Test question",
                "options": ["Option 1", "Option 2"],
                "server_id": "987654321",
                "channel_id": "123456789",
            }

            response = self.pentest.client.post(
                "/htmx/create-poll",
                data=poll_data,
                cookies={"access_token": self.pentest.admin_token},
            )

            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()

            # Should not cause time delays (indicating SQL injection)
            assert duration < 3.0, f"Possible time-based SQL injection: {duration}s"


# Integration test to run all pentest suites
class TestPentestIntegration:
    """Integration test to run all penetration tests"""

    def test_run_all_pentests(self):
        """Run all penetration test suites"""
        test_classes = [
            TestAuthenticationSecurity,
            TestInputValidationSecurity,
            TestFileUploadSecurity,
            TestAPIEndpointSecurity,
            TestBusinessLogicSecurity,
            TestInformationDisclosure,
            TestCSRFAndClickjacking,
            TestDatabaseSecurity,
        ]

        results = {}

        for test_class in test_classes:
            class_name = test_class.__name__
            results[class_name] = {"passed": 0, "failed": 0, "errors": []}

            # Get all test methods
            test_methods = [
                method for method in dir(test_class) if method.startswith("test_")
            ]

            for method_name in test_methods:
                try:
                    # Create instance and run test
                    instance = test_class()
                    instance.setup_method()
                    method = getattr(instance, method_name)
                    method()
                    results[class_name]["passed"] += 1
                except Exception as e:
                    results[class_name]["failed"] += 1
                    results[class_name]["errors"].append(f"{method_name}: {str(e)}")

        # Print results summary
        print("\n" + "=" * 60)
        print("PENETRATION TEST RESULTS SUMMARY")
        print("=" * 60)

        total_passed = 0
        total_failed = 0

        for class_name, result in results.items():
            passed = result["passed"]
            failed = result["failed"]
            total_passed += passed
            total_failed += failed

            status = "✅ PASS" if failed == 0 else "❌ FAIL"
            print(f"{status} {class_name}: {passed} passed, {failed} failed")

            if result["errors"]:
                for error in result["errors"]:
                    print(f"  - {error}")

        print("=" * 60)
        print(f"TOTAL: {total_passed} passed, {total_failed} failed")
        print("=" * 60)

        # Assert overall success
        assert total_failed == 0, f"Penetration tests failed: {total_failed} failures"


if __name__ == "__main__":
    # Run the integration test
    integration_test = TestPentestIntegration()
    integration_test.test_run_all_pentests()
