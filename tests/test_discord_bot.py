"""
Discord bot tests for Polly.
Tests Discord bot functionality, event handling, and edge cases.
"""

import pytest
from unittest.mock import Mock, AsyncMock, patch
import discord

from polly.discord_bot import (
    bot,
    on_ready,
    create_quick_poll_command,
    on_reaction_add,
    start_bot,
    shutdown_bot,
    get_bot_instance,
)
from polly.database import POLL_EMOJIS


class TestDiscordBotSetup:
    """Test Discord bot setup and configuration."""

    def test_bot_instance_creation(self):
        """Test bot instance is created properly."""
        assert bot is not None
        assert isinstance(bot, discord.ext.commands.Bot)
        assert bot.command_prefix == "!"
        assert bot.intents.message_content is True
        assert bot.intents.guilds is True
        assert bot.intents.reactions is True

    def test_get_bot_instance(self):
        """Test get_bot_instance function."""
        bot_instance = get_bot_instance()
        assert bot_instance is bot


class TestBotEvents:
    """Test Discord bot event handlers."""

    @pytest.mark.asyncio
    async def test_on_ready_success(self):
        """Test successful bot ready event."""
        with (
            patch.object(bot, "user") as mock_user,
            patch.object(bot.tree, "sync", new_callable=AsyncMock) as mock_sync,
        ):
            mock_user.name = "TestBot"
            mock_sync.return_value = ["command1", "command2"]

            await on_ready()

            mock_sync.assert_called_once()

    @pytest.mark.asyncio
    async def test_on_ready_sync_failure(self):
        """Test bot ready event with sync failure."""
        with (
            patch.object(bot, "user") as mock_user,
            patch.object(bot.tree, "sync", new_callable=AsyncMock) as mock_sync,
            patch("polly.discord_bot.notify_error") as mock_notify,
        ):
            mock_user.name = "TestBot"
            mock_sync.side_effect = Exception("Sync failed")

            await on_ready()

            mock_sync.assert_called_once()
            mock_notify.assert_called_once()


class TestQuickPollCommand:
    """Test quick poll slash command."""

    @pytest.mark.asyncio
    async def test_create_quick_poll_success(
        self, mock_discord_user, mock_discord_guild, db_session
    ):
        """Test successful quick poll creation."""
        # Mock interaction
        interaction = Mock()
        interaction.user = mock_discord_user
        interaction.guild_id = 123456789
        interaction.guild = mock_discord_guild
        interaction.channel_id = 555555555
        interaction.channel = Mock()
        interaction.channel.name = "test-channel"
        interaction.response = Mock()
        interaction.response.send_message = AsyncMock()
        interaction.original_response = AsyncMock()

        # Mock message for reactions
        mock_message = Mock()
        mock_message.id = 777777777
        mock_message.add_reaction = AsyncMock()
        interaction.original_response.return_value = mock_message

        # Mock user permissions
        with (
            patch("polly.discord_bot.user_has_admin_permissions", return_value=True),
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.get_scheduler") as mock_get_scheduler,
        ):
            mock_scheduler = Mock()
            mock_scheduler.add_job = Mock()
            mock_get_scheduler.return_value = mock_scheduler

            await create_quick_poll_command(
                interaction,
                "Test question?",
                "Option 1",
                "Option 2",
                "Option 3",
                anonymous=False,
            )

            interaction.response.send_message.assert_called_once()
            assert mock_message.add_reaction.call_count == 3  # 3 options
            mock_scheduler.add_job.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_quick_poll_no_permissions(self, mock_discord_user):
        """Test quick poll creation without permissions."""
        interaction = Mock()
        interaction.user = mock_discord_user
        interaction.response = Mock()
        interaction.response.send_message = AsyncMock()

        with patch("polly.discord_bot.user_has_admin_permissions", return_value=False):
            await create_quick_poll_command(
                interaction, "Test question?", "Option 1", "Option 2"
            )

            interaction.response.send_message.assert_called_once()
            call_args = interaction.response.send_message.call_args
            assert "need Administrator" in call_args[0][0]
            assert call_args[1]["ephemeral"] is True

    @pytest.mark.asyncio
    async def test_create_quick_poll_too_many_options(self, mock_discord_user):
        """Test quick poll creation with too many options."""
        interaction = Mock()
        interaction.user = mock_discord_user
        interaction.response = Mock()
        interaction.response.send_message = AsyncMock()

        with patch("polly.discord_bot.user_has_admin_permissions", return_value=True):
            # Create 11 options (too many)
            options = ["Option " + str(i) for i in range(11)]

            await create_quick_poll_command(
                interaction,
                "Test question?",
                *options[:5],  # Only first 5 can be passed as parameters
            )

            # Should still work since we only pass 5 options max
            interaction.response.send_message.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_quick_poll_database_error(
        self, mock_discord_user, mock_discord_guild
    ):
        """Test quick poll creation with database error."""
        interaction = Mock()
        interaction.user = mock_discord_user
        interaction.guild_id = 123456789
        interaction.guild = mock_discord_guild
        interaction.channel_id = 555555555
        interaction.channel = Mock()
        interaction.channel.name = "test-channel"
        interaction.response = Mock()
        interaction.response.send_message = AsyncMock()
        interaction.response.is_done.return_value = False

        with (
            patch("polly.discord_bot.user_has_admin_permissions", return_value=True),
            patch("polly.discord_bot.get_db_session") as mock_get_db,
            patch("polly.discord_bot.notify_error_async") as mock_notify,
        ):
            mock_session = Mock()
            mock_session.add.side_effect = Exception("Database error")
            mock_get_db.return_value = mock_session

            await create_quick_poll_command(
                interaction, "Test question?", "Option 1", "Option 2"
            )

            mock_notify.assert_called_once()
            interaction.response.send_message.assert_called()
            call_args = interaction.response.send_message.call_args
            assert "Error creating poll" in call_args[0][0]


class TestReactionHandling:
    """Test reaction-based voting."""

    @pytest.mark.asyncio
    async def test_on_reaction_add_bot_user(self, mock_bot):
        """Test reaction from bot user (should be ignored)."""
        reaction = Mock()
        bot_user = Mock()
        bot_user.bot = True

        with patch("polly.discord_bot.get_db_session") as mock_get_db:
            await on_reaction_add(reaction, bot_user)
            mock_get_db.assert_not_called()

    @pytest.mark.asyncio
    async def test_on_reaction_add_non_poll_message(
        self, mock_discord_user, db_session
    ):
        """Test reaction on non-poll message."""
        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 999999999  # Non-existent message ID

        with patch("polly.discord_bot.get_db_session", return_value=db_session):
            await on_reaction_add(reaction, mock_discord_user)
            # Should return early without error

    @pytest.mark.asyncio
    async def test_on_reaction_add_inactive_poll(
        self, mock_discord_user, sample_poll, db_session
    ):
        """Test reaction on inactive poll."""
        sample_poll.status = "closed"
        sample_poll.message_id = "777777777"
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"

        with patch("polly.discord_bot.get_db_session", return_value=db_session):
            await on_reaction_add(reaction, mock_discord_user)
            # Should return early without processing vote

    @pytest.mark.asyncio
    async def test_on_reaction_add_invalid_emoji(
        self, mock_discord_user, sample_poll, db_session
    ):
        """Test reaction with invalid emoji."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "‚ùå"  # Not a valid poll emoji

        with patch("polly.discord_bot.get_db_session", return_value=db_session):
            await on_reaction_add(reaction, mock_discord_user)
            # Should return early without processing vote

    @pytest.mark.asyncio
    async def test_on_reaction_add_successful_vote(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test successful vote via reaction."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]  # Use default emojis
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"  # First option
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_dm.assert_called_once()
            mock_update.assert_called_once()
            reaction.remove.assert_called_once_with(mock_discord_user)

    @pytest.mark.asyncio
    async def test_on_reaction_add_vote_failure(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test failed vote via reaction."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"
        reaction.remove = AsyncMock()

        mock_result = {
            "success": False,
            "error": "Vote failed",
            "message": "Error message",
        }

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch("polly.discord_bot.PollErrorHandler") as mock_error_handler,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_error_handler.handle_vote_error = AsyncMock(
                return_value="Error handled"
            )

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_error_handler.handle_vote_error.assert_called_once()
            reaction.remove.assert_not_called()  # Don't remove reaction on failure

    @pytest.mark.asyncio
    async def test_on_reaction_add_multiple_choice_keep_reaction(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test multiple choice poll keeps reactions."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        sample_poll.anonymous = False
        sample_poll.multiple_choice = True
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_dm.assert_called_once()
            mock_update.assert_called_once()
            reaction.remove.assert_not_called()  # Keep reaction for multiple choice

    @pytest.mark.asyncio
    async def test_on_reaction_add_anonymous_poll_remove_reaction(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test anonymous poll removes reactions."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        sample_poll.anonymous = True
        sample_poll.multiple_choice = False
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_dm.assert_called_once()
            mock_update.assert_called_once()
            reaction.remove.assert_called_once_with(
                mock_discord_user
            )  # Remove for anonymous

    @pytest.mark.asyncio
    async def test_on_reaction_add_dm_failure(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test reaction handling when DM fails."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = False  # DM failed

            await on_reaction_add(reaction, mock_discord_user)

            # Vote should still be processed even if DM fails
            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_update.assert_called_once()
            reaction.remove.assert_called_once_with(mock_discord_user)

    @pytest.mark.asyncio
    async def test_on_reaction_add_reaction_removal_failure(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test reaction handling when reaction removal fails."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"
        reaction.remove = AsyncMock(side_effect=Exception("Removal failed"))

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            await on_reaction_add(reaction, mock_discord_user)

            # Vote should still be processed even if reaction removal fails
            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_update.assert_called_once()
            reaction.remove.assert_called_once_with(mock_discord_user)

    @pytest.mark.asyncio
    async def test_on_reaction_add_critical_error(self, mock_discord_user, db_session):
        """Test reaction handling with critical error."""
        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üá¶"

        with (
            patch(
                "polly.discord_bot.get_db_session",
                side_effect=Exception("Critical error"),
            ),
            patch("polly.discord_bot.PollErrorHandler") as mock_error_handler,
            patch("polly.discord_bot.notify_error_async") as mock_notify,
        ):
            mock_error_handler.handle_vote_error = AsyncMock(
                return_value="Error handled"
            )

            await on_reaction_add(reaction, mock_discord_user)

            mock_error_handler.handle_vote_error.assert_called_once()
            mock_notify.assert_called_once()


class TestBotLifecycle:
    """Test bot startup and shutdown."""

    @pytest.mark.asyncio
    async def test_start_bot_with_token(self):
        """Test bot startup with token."""
        with (
            patch.dict("os.environ", {"DISCORD_TOKEN": "test_token"}),
            patch.object(bot, "start", new_callable=AsyncMock) as mock_start,
        ):
            await start_bot()
            mock_start.assert_called_once_with("test_token")

    @pytest.mark.asyncio
    async def test_shutdown_bot_open(self):
        """Test bot shutdown when bot is open."""
        with (
            patch.object(bot, "is_closed", return_value=False),
            patch.object(bot, "close", new_callable=AsyncMock) as mock_close,
        ):
            await shutdown_bot()
            mock_close.assert_called_once()

    @pytest.mark.asyncio
    async def test_shutdown_bot_already_closed(self):
        """Test bot shutdown when bot is already closed."""
        with (
            patch.object(bot, "is_closed", return_value=True),
            patch.object(bot, "close", new_callable=AsyncMock) as mock_close,
        ):
            await shutdown_bot()
            mock_close.assert_not_called()


class TestBotEdgeCases:
    """Test bot edge cases and error conditions."""

    @pytest.mark.asyncio
    async def test_on_reaction_add_with_custom_emojis(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test reaction handling with custom Discord emojis."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = ["<:custom:123456789>", "<a:animated:987654321>"]
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "<:custom:123456789>"
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_dm.assert_called_once()
            mock_update.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_quick_poll_with_edge_case_inputs(
        self, mock_discord_user, mock_discord_guild, edge_case_strings
    ):
        """Test quick poll creation with edge case inputs."""
        interaction = Mock()
        interaction.user = mock_discord_user
        interaction.guild_id = 123456789
        interaction.guild = mock_discord_guild
        interaction.channel_id = 555555555
        interaction.channel = Mock()
        interaction.channel.name = "test-channel"
        interaction.response = Mock()
        interaction.response.send_message = AsyncMock()
        interaction.response.is_done.return_value = False

        with patch("polly.discord_bot.user_has_admin_permissions", return_value=True):
            for case_name, case_value in edge_case_strings.items():
                if len(case_value) > 5:  # Valid question length
                    try:
                        await create_quick_poll_command(
                            interaction, case_value, "Option 1", "Option 2"
                        )
                        # Should handle gracefully
                    except Exception as e:
                        # Some edge cases may cause exceptions
                        assert isinstance(e, (ValueError, TypeError, UnicodeError))

    @pytest.mark.asyncio
    async def test_on_reaction_add_with_malicious_inputs(
        self, mock_discord_user, sample_poll, db_session, malicious_inputs
    ):
        """Test reaction handling with malicious inputs."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = POLL_EMOJIS[:4]
        db_session.commit()

        for input_name, malicious_value in malicious_inputs.items():
            reaction = Mock()
            reaction.message = Mock()
            reaction.message.id = 777777777
            reaction.emoji = str(malicious_value)[:10]  # Limit length

            with patch("polly.discord_bot.get_db_session", return_value=db_session):
                try:
                    await on_reaction_add(reaction, mock_discord_user)
                    # Should handle gracefully
                except Exception as e:
                    # Some malicious inputs may cause exceptions
                    assert isinstance(e, (ValueError, TypeError, UnicodeError))


class TestBotIntegration:
    """Test bot integration with other components."""

    @pytest.mark.asyncio
    async def test_emoji_handler_integration(
        self, mock_discord_user, sample_poll, db_session, mock_bot
    ):
        """Test integration with emoji handler."""
        sample_poll.status = "active"
        sample_poll.message_id = "777777777"
        sample_poll.emojis = ["üêàÔ∏è", "üñ§Ô∏è"]  # Emojis with variation selectors
        db_session.commit()

        reaction = Mock()
        reaction.message = Mock()
        reaction.message.id = 777777777
        reaction.emoji = "üêàÔ∏è"
        reaction.remove = AsyncMock()

        mock_result = {"success": True, "action": "added", "message": "Vote recorded"}

        with (
            patch("polly.discord_bot.get_db_session", return_value=db_session),
            patch("polly.discord_bot.BulletproofPollOperations") as mock_bulletproof,
            patch(
                "polly.discord_bot.send_vote_confirmation_dm", new_callable=AsyncMock
            ) as mock_dm,
            patch(
                "polly.discord_bot.update_poll_message", new_callable=AsyncMock
            ) as mock_update,
            patch("polly.discord_bot.DiscordEmojiHandler") as mock_emoji_handler,
        ):
            mock_ops = Mock()
            mock_ops.bulletproof_vote_collection = AsyncMock(return_value=mock_result)
            mock_bulletproof.return_value = mock_ops
            mock_dm.return_value = True

            mock_handler = Mock()
            mock_handler.prepare_emoji_for_reaction = Mock(side_effect=lambda x: x)
            mock_emoji_handler.return_value = mock_handler

            await on_reaction_add(reaction, mock_discord_user)

            mock_ops.bulletproof_vote_collection.assert_called_once()
            mock_update.assert_called_once()


# Confidence level: 10/10 - Comprehensive Discord bot testing with all scenarios
