"""
Polly Security Penetration Test Runner
Comprehensive security testing suite runner with detailed reporting.
"""

import sys
import json
from datetime import datetime
from pathlib import Path

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Import test suites
from tests.test_pentest import TestPentestIntegration
from tests.test_web_pentest import TestWebPentestIntegration


class SecurityTestRunner:
    """Main security test runner with comprehensive reporting"""

    def __init__(self, base_url=None, use_live_server=False):
        self.start_time = datetime.now()
        self.base_url = (
            base_url or "https://polly.pacnp.al"
            if use_live_server
            else "http://localhost:8000"
        )
        self.use_live_server = use_live_server
        self.results = {
            "timestamp": self.start_time.isoformat(),
            "target_url": self.base_url,
            "test_mode": "live_server" if use_live_server else "local_testing",
            "test_suites": {},
            "summary": {},
            "recommendations": [],
        }

    def run_api_pentests(self):
        """Run API and backend penetration tests"""
        print("\n" + "=" * 80)
        print("üîí RUNNING API & BACKEND PENETRATION TESTS")
        print("=" * 80)

        try:
            integration_test = TestPentestIntegration()
            api_results = integration_test.test_run_all_pentests()

            self.results["test_suites"]["api_backend"] = {
                "status": "completed",
                "results": api_results,
                "timestamp": datetime.now().isoformat(),
            }

            return True

        except Exception as e:
            print(f"‚ùå API pentest failed: {e}")
            self.results["test_suites"]["api_backend"] = {
                "status": "failed",
                "error": str(e),
                "timestamp": datetime.now().isoformat(),
            }
            return False

    def run_web_pentests(self):
        """Run web interface penetration tests"""
        print("\n" + "=" * 80)
        print("üåê RUNNING WEB INTERFACE PENETRATION TESTS")
        print("=" * 80)

        try:
            web_integration_test = TestWebPentestIntegration()
            web_results = web_integration_test.test_run_all_web_pentests()

            self.results["test_suites"]["web_interface"] = {
                "status": "completed",
                "results": web_results,
                "timestamp": datetime.now().isoformat(),
            }

            return True

        except Exception as e:
            print(f"‚ùå Web pentest failed: {e}")
            self.results["test_suites"]["web_interface"] = {
                "status": "failed",
                "error": str(e),
                "timestamp": datetime.now().isoformat(),
            }
            return False

    def analyze_results(self):
        """Analyze test results and generate recommendations"""
        print("\n" + "=" * 80)
        print("üìä ANALYZING SECURITY TEST RESULTS")
        print("=" * 80)

        total_passed = 0
        total_failed = 0
        critical_issues = []
        recommendations = []

        # Analyze API/Backend results
        api_results = (
            self.results["test_suites"].get("api_backend", {}).get("results", {})
        )
        for test_class, results in api_results.items():
            passed = results.get("passed", 0)
            failed = results.get("failed", 0)
            errors = results.get("errors", [])

            total_passed += passed
            total_failed += failed

            # Identify critical security issues
            if "Authentication" in test_class and failed > 0:
                critical_issues.append(
                    f"Authentication vulnerabilities detected in {test_class}"
                )
                recommendations.append("Implement stronger authentication mechanisms")

            if "InputValidation" in test_class and failed > 0:
                critical_issues.append(
                    f"Input validation issues detected in {test_class}"
                )
                recommendations.append(
                    "Implement comprehensive input validation and sanitization"
                )

            if "FileUpload" in test_class and failed > 0:
                critical_issues.append(
                    f"File upload security issues detected in {test_class}"
                )
                recommendations.append(
                    "Implement strict file upload validation and sandboxing"
                )

        # Analyze Web Interface results
        web_results = (
            self.results["test_suites"].get("web_interface", {}).get("results", {})
        )
        for test_class, results in web_results.items():
            passed = results.get("passed", 0)
            failed = results.get("failed", 0)

            total_passed += passed
            total_failed += failed

            if "ClientSide" in test_class and failed > 0:
                critical_issues.append(
                    f"Client-side security issues detected in {test_class}"
                )
                recommendations.append(
                    "Implement Content Security Policy and security headers"
                )

        # Generate summary
        self.results["summary"] = {
            "total_tests": total_passed + total_failed,
            "passed": total_passed,
            "failed": total_failed,
            "success_rate": (total_passed / (total_passed + total_failed)) * 100
            if (total_passed + total_failed) > 0
            else 0,
            "critical_issues": len(critical_issues),
            "risk_level": self.calculate_risk_level(total_failed, len(critical_issues)),
        }

        self.results["critical_issues"] = critical_issues
        self.results["recommendations"] = list(
            set(recommendations)
        )  # Remove duplicates

        # Add standard security recommendations
        self.add_standard_recommendations()

    def calculate_risk_level(self, failed_tests, critical_issues):
        """Calculate overall security risk level"""
        if critical_issues > 5 or failed_tests > 20:
            return "HIGH"
        elif critical_issues > 2 or failed_tests > 10:
            return "MEDIUM"
        elif critical_issues > 0 or failed_tests > 5:
            return "LOW"
        else:
            return "MINIMAL"

    def add_standard_recommendations(self):
        """Add standard security recommendations"""
        standard_recommendations = [
            "Implement rate limiting on all API endpoints",
            "Add comprehensive logging and monitoring",
            "Use HTTPS in production with proper SSL/TLS configuration",
            "Implement proper session management with secure cookies",
            "Add CSRF protection to all state-changing operations",
            "Implement proper error handling without information disclosure",
            "Use parameterized queries to prevent SQL injection",
            "Implement proper file upload validation and storage",
            "Add security headers (CSP, X-Frame-Options, etc.)",
            "Implement proper input validation and output encoding",
            "Use secure authentication mechanisms (OAuth, JWT with proper validation)",
            "Implement proper authorization checks on all endpoints",
            "Regular security updates and dependency scanning",
            "Implement proper backup and disaster recovery procedures",
        ]

        # Add recommendations that aren't already present
        for rec in standard_recommendations:
            if rec not in self.results["recommendations"]:
                self.results["recommendations"].append(rec)

    def generate_report(self):
        """Generate comprehensive security report"""
        end_time = datetime.now()
        duration = (end_time - self.start_time).total_seconds()

        print("\n" + "=" * 80)
        print("üìã SECURITY PENETRATION TEST REPORT")
        print("=" * 80)
        print(f"Test Duration: {duration:.2f} seconds")
        print(f"Timestamp: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print()

        # Summary
        summary = self.results["summary"]
        print("üìä SUMMARY")
        print("-" * 40)
        print(f"Total Tests: {summary['total_tests']}")
        print(f"Passed: {summary['passed']} ‚úÖ")
        print(f"Failed: {summary['failed']} ‚ùå")
        print(f"Success Rate: {summary['success_rate']:.1f}%")
        print(f"Risk Level: {summary['risk_level']}")
        print()

        # Critical Issues
        if self.results.get("critical_issues"):
            print("üö® CRITICAL SECURITY ISSUES")
            print("-" * 40)
            for issue in self.results["critical_issues"]:
                print(f"‚ùå {issue}")
            print()

        # Test Suite Results
        print("üîç DETAILED TEST RESULTS")
        print("-" * 40)

        for suite_name, suite_data in self.results["test_suites"].items():
            print(f"\n{suite_name.upper().replace('_', ' ')}:")

            if suite_data["status"] == "failed":
                print(f"  ‚ùå FAILED: {suite_data.get('error', 'Unknown error')}")
                continue

            results = suite_data.get("results", {})
            for test_class, test_results in results.items():
                passed = test_results.get("passed", 0)
                failed = test_results.get("failed", 0)
                status = "‚úÖ" if failed == 0 else "‚ùå"
                print(f"  {status} {test_class}: {passed} passed, {failed} failed")

                # Show errors if any
                errors = test_results.get("errors", [])
                if errors:
                    for error in errors[:3]:  # Show first 3 errors
                        print(f"    - {error}")
                    if len(errors) > 3:
                        print(f"    ... and {len(errors) - 3} more errors")

        # Recommendations
        print("\nüí° SECURITY RECOMMENDATIONS")
        print("-" * 40)
        for i, rec in enumerate(self.results["recommendations"], 1):
            print(f"{i:2d}. {rec}")

        print("\n" + "=" * 80)

        # Save report to file
        self.save_report()

    def save_report(self):
        """Save detailed report to JSON file"""
        report_file = f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        report_path = Path("tests") / report_file

        try:
            with open(report_path, "w") as f:
                json.dump(self.results, f, indent=2, default=str)

            print(f"üìÑ Detailed report saved to: {report_path}")

        except Exception as e:
            print(f"‚ùå Failed to save report: {e}")

    def run_all_tests(self):
        """Run all penetration tests"""
        print("üîí POLLY SECURITY PENETRATION TEST SUITE")
        print("=" * 80)
        print("Starting comprehensive security testing...")
        print(f"Timestamp: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}")

        # Run API tests
        api_success = self.run_api_pentests()

        # Run web tests
        web_success = self.run_web_pentests()

        # Analyze results
        self.analyze_results()

        # Generate report
        self.generate_report()

        # Return overall success
        return api_success and web_success


def main():
    """Main entry point"""
    runner = SecurityTestRunner()

    try:
        success = runner.run_all_tests()

        if success:
            print("\n‚úÖ Security testing completed successfully!")
            return 0
        else:
            print("\n‚ùå Security testing completed with errors!")
            return 1

    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Security testing interrupted by user")
        return 130

    except Exception as e:
        print(f"\nüí• Security testing failed with error: {e}")
        return 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
